#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def match_tbl_table_add_with_tcp_sport_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec
    """
    pass

  def match_tbl_table_add_with_tcp_dport_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec
    """
    pass

  def match_tbl_table_add_with_ipsa_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec
    """
    pass

  def match_tbl_table_add_with_ipda_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec
    """
    pass

  def match_tbl_table_modify_with_tcp_sport_modify(self, sess_hdl, dev_id, entry, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
     - action_spec
    """
    pass

  def match_tbl_table_modify_with_tcp_dport_modify(self, sess_hdl, dev_id, entry, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
     - action_spec
    """
    pass

  def match_tbl_table_modify_with_ipsa_modify(self, sess_hdl, dev_id, entry, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
     - action_spec
    """
    pass

  def match_tbl_table_modify_with_ipda_modify(self, sess_hdl, dev_id, entry, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
     - action_spec
    """
    pass

  def match_tbl_table_delete(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    pass

  def match_tbl_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def match_tbl_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def match_tbl_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def match_tbl_set_default_action_tcp_sport_modify(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    pass

  def match_tbl_set_default_action_tcp_dport_modify(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    pass

  def match_tbl_set_default_action_ipsa_modify(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    pass

  def match_tbl_set_default_action_ipda_modify(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    pass

  def match_tbl_activate_entry(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    pass

  def match_tbl_deactivate_entry(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    pass

  def match_tbl_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def set_learning_timeout(self, sess_hdl, dev_id, usecs):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - usecs
    """
    pass

  def tbl_dbg_counter_type_set(self, dev_tgt, tbl_name, type):
    """
    Parameters:
     - dev_tgt
     - tbl_name
     - type
    """
    pass

  def tbl_dbg_counter_get(self, dev_tgt, tbl_name):
    """
    Parameters:
     - dev_tgt
     - tbl_name
    """
    pass

  def tbl_dbg_counter_clear(self, dev_tgt, tbl_name):
    """
    Parameters:
     - dev_tgt
     - tbl_name
    """
    pass

  def tbl_dbg_counter_type_stage_set(self, dev_tgt, stage, type):
    """
    Parameters:
     - dev_tgt
     - stage
     - type
    """
    pass

  def tbl_dbg_counter_stage_clear(self, dev_tgt, stage):
    """
    Parameters:
     - dev_tgt
     - stage
    """
    pass

  def snapshot_create(self, dev_tgt, start_stage, end_stage, direction):
    """
    Parameters:
     - dev_tgt
     - start_stage
     - end_stage
     - direction
    """
    pass

  def snapshot_delete(self, handle):
    """
    Parameters:
     - handle
    """
    pass

  def snapshot_state_set(self, handle, state, usecs):
    """
    Parameters:
     - handle
     - state
     - usecs
    """
    pass

  def snapshot_state_get(self, handle, pipe):
    """
    Parameters:
     - handle
     - pipe
    """
    pass

  def snapshot_timer_enable(self, handle, disable):
    """
    Parameters:
     - handle
     - disable
    """
    pass

  def snapshot_capture_trigger_set(self, handle, trig_spec, trig_spec2):
    """
    Parameters:
     - handle
     - trig_spec
     - trig_spec2
    """
    pass

  def snapshot_capture_data_get(self, handle, pipe, stage_id, field_name):
    """
    Parameters:
     - handle
     - pipe
     - stage_id
     - field_name
    """
    pass

  def counter_read_cntr(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    pass

  def counter_write_cntr(self, sess_hdl, dev_tgt, index, counter_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - counter_value
    """
    pass

  def counter_hw_sync_cntr(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def meter_set_mtr(self, sess_hdl, dev_tgt, index, meter_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - meter_spec
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def match_tbl_table_add_with_tcp_sport_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec
    """
    self.send_match_tbl_table_add_with_tcp_sport_modify(sess_hdl, dev_tgt, match_spec, action_spec)
    return self.recv_match_tbl_table_add_with_tcp_sport_modify()

  def send_match_tbl_table_add_with_tcp_sport_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    self._oprot.writeMessageBegin('match_tbl_table_add_with_tcp_sport_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_table_add_with_tcp_sport_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_table_add_with_tcp_sport_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_table_add_with_tcp_sport_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_table_add_with_tcp_sport_modify failed: unknown result");

  def match_tbl_table_add_with_tcp_dport_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec
    """
    self.send_match_tbl_table_add_with_tcp_dport_modify(sess_hdl, dev_tgt, match_spec, action_spec)
    return self.recv_match_tbl_table_add_with_tcp_dport_modify()

  def send_match_tbl_table_add_with_tcp_dport_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    self._oprot.writeMessageBegin('match_tbl_table_add_with_tcp_dport_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_table_add_with_tcp_dport_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_table_add_with_tcp_dport_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_table_add_with_tcp_dport_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_table_add_with_tcp_dport_modify failed: unknown result");

  def match_tbl_table_add_with_ipsa_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec
    """
    self.send_match_tbl_table_add_with_ipsa_modify(sess_hdl, dev_tgt, match_spec, action_spec)
    return self.recv_match_tbl_table_add_with_ipsa_modify()

  def send_match_tbl_table_add_with_ipsa_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    self._oprot.writeMessageBegin('match_tbl_table_add_with_ipsa_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_table_add_with_ipsa_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_table_add_with_ipsa_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_table_add_with_ipsa_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_table_add_with_ipsa_modify failed: unknown result");

  def match_tbl_table_add_with_ipda_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec
    """
    self.send_match_tbl_table_add_with_ipda_modify(sess_hdl, dev_tgt, match_spec, action_spec)
    return self.recv_match_tbl_table_add_with_ipda_modify()

  def send_match_tbl_table_add_with_ipda_modify(self, sess_hdl, dev_tgt, match_spec, action_spec):
    self._oprot.writeMessageBegin('match_tbl_table_add_with_ipda_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_table_add_with_ipda_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_table_add_with_ipda_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_table_add_with_ipda_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_table_add_with_ipda_modify failed: unknown result");

  def match_tbl_table_modify_with_tcp_sport_modify(self, sess_hdl, dev_id, entry, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
     - action_spec
    """
    self.send_match_tbl_table_modify_with_tcp_sport_modify(sess_hdl, dev_id, entry, action_spec)
    return self.recv_match_tbl_table_modify_with_tcp_sport_modify()

  def send_match_tbl_table_modify_with_tcp_sport_modify(self, sess_hdl, dev_id, entry, action_spec):
    self._oprot.writeMessageBegin('match_tbl_table_modify_with_tcp_sport_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_table_modify_with_tcp_sport_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_table_modify_with_tcp_sport_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_table_modify_with_tcp_sport_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_table_modify_with_tcp_sport_modify failed: unknown result");

  def match_tbl_table_modify_with_tcp_dport_modify(self, sess_hdl, dev_id, entry, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
     - action_spec
    """
    self.send_match_tbl_table_modify_with_tcp_dport_modify(sess_hdl, dev_id, entry, action_spec)
    return self.recv_match_tbl_table_modify_with_tcp_dport_modify()

  def send_match_tbl_table_modify_with_tcp_dport_modify(self, sess_hdl, dev_id, entry, action_spec):
    self._oprot.writeMessageBegin('match_tbl_table_modify_with_tcp_dport_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_table_modify_with_tcp_dport_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_table_modify_with_tcp_dport_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_table_modify_with_tcp_dport_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_table_modify_with_tcp_dport_modify failed: unknown result");

  def match_tbl_table_modify_with_ipsa_modify(self, sess_hdl, dev_id, entry, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
     - action_spec
    """
    self.send_match_tbl_table_modify_with_ipsa_modify(sess_hdl, dev_id, entry, action_spec)
    return self.recv_match_tbl_table_modify_with_ipsa_modify()

  def send_match_tbl_table_modify_with_ipsa_modify(self, sess_hdl, dev_id, entry, action_spec):
    self._oprot.writeMessageBegin('match_tbl_table_modify_with_ipsa_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_table_modify_with_ipsa_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_table_modify_with_ipsa_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_table_modify_with_ipsa_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_table_modify_with_ipsa_modify failed: unknown result");

  def match_tbl_table_modify_with_ipda_modify(self, sess_hdl, dev_id, entry, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
     - action_spec
    """
    self.send_match_tbl_table_modify_with_ipda_modify(sess_hdl, dev_id, entry, action_spec)
    return self.recv_match_tbl_table_modify_with_ipda_modify()

  def send_match_tbl_table_modify_with_ipda_modify(self, sess_hdl, dev_id, entry, action_spec):
    self._oprot.writeMessageBegin('match_tbl_table_modify_with_ipda_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_table_modify_with_ipda_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_table_modify_with_ipda_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_table_modify_with_ipda_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_table_modify_with_ipda_modify failed: unknown result");

  def match_tbl_table_delete(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    self.send_match_tbl_table_delete(sess_hdl, dev_id, entry)
    return self.recv_match_tbl_table_delete()

  def send_match_tbl_table_delete(self, sess_hdl, dev_id, entry):
    self._oprot.writeMessageBegin('match_tbl_table_delete', TMessageType.CALL, self._seqid)
    args = match_tbl_table_delete_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_table_delete(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_table_delete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_table_delete failed: unknown result");

  def match_tbl_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_match_tbl_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_match_tbl_get_first_entry_handle()

  def send_match_tbl_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('match_tbl_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = match_tbl_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_get_first_entry_handle(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_get_first_entry_handle_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_get_first_entry_handle failed: unknown result");

  def match_tbl_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_match_tbl_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_match_tbl_get_next_entry_handles()

  def send_match_tbl_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('match_tbl_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = match_tbl_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_get_next_entry_handles(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_get_next_entry_handles_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_get_next_entry_handles failed: unknown result");

  def match_tbl_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_match_tbl_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_match_tbl_get_entry()

  def send_match_tbl_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('match_tbl_get_entry', TMessageType.CALL, self._seqid)
    args = match_tbl_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_get_entry(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_get_entry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_get_entry failed: unknown result");

  def match_tbl_set_default_action_tcp_sport_modify(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    self.send_match_tbl_set_default_action_tcp_sport_modify(sess_hdl, dev_tgt, action_spec)
    return self.recv_match_tbl_set_default_action_tcp_sport_modify()

  def send_match_tbl_set_default_action_tcp_sport_modify(self, sess_hdl, dev_tgt, action_spec):
    self._oprot.writeMessageBegin('match_tbl_set_default_action_tcp_sport_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_set_default_action_tcp_sport_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_set_default_action_tcp_sport_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_set_default_action_tcp_sport_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_set_default_action_tcp_sport_modify failed: unknown result");

  def match_tbl_set_default_action_tcp_dport_modify(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    self.send_match_tbl_set_default_action_tcp_dport_modify(sess_hdl, dev_tgt, action_spec)
    return self.recv_match_tbl_set_default_action_tcp_dport_modify()

  def send_match_tbl_set_default_action_tcp_dport_modify(self, sess_hdl, dev_tgt, action_spec):
    self._oprot.writeMessageBegin('match_tbl_set_default_action_tcp_dport_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_set_default_action_tcp_dport_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_set_default_action_tcp_dport_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_set_default_action_tcp_dport_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_set_default_action_tcp_dport_modify failed: unknown result");

  def match_tbl_set_default_action_ipsa_modify(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    self.send_match_tbl_set_default_action_ipsa_modify(sess_hdl, dev_tgt, action_spec)
    return self.recv_match_tbl_set_default_action_ipsa_modify()

  def send_match_tbl_set_default_action_ipsa_modify(self, sess_hdl, dev_tgt, action_spec):
    self._oprot.writeMessageBegin('match_tbl_set_default_action_ipsa_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_set_default_action_ipsa_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_set_default_action_ipsa_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_set_default_action_ipsa_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_set_default_action_ipsa_modify failed: unknown result");

  def match_tbl_set_default_action_ipda_modify(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    self.send_match_tbl_set_default_action_ipda_modify(sess_hdl, dev_tgt, action_spec)
    return self.recv_match_tbl_set_default_action_ipda_modify()

  def send_match_tbl_set_default_action_ipda_modify(self, sess_hdl, dev_tgt, action_spec):
    self._oprot.writeMessageBegin('match_tbl_set_default_action_ipda_modify', TMessageType.CALL, self._seqid)
    args = match_tbl_set_default_action_ipda_modify_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_set_default_action_ipda_modify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_set_default_action_ipda_modify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_set_default_action_ipda_modify failed: unknown result");

  def match_tbl_activate_entry(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    self.send_match_tbl_activate_entry(sess_hdl, dev_id, entry)
    return self.recv_match_tbl_activate_entry()

  def send_match_tbl_activate_entry(self, sess_hdl, dev_id, entry):
    self._oprot.writeMessageBegin('match_tbl_activate_entry', TMessageType.CALL, self._seqid)
    args = match_tbl_activate_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_activate_entry(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_activate_entry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_activate_entry failed: unknown result");

  def match_tbl_deactivate_entry(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    self.send_match_tbl_deactivate_entry(sess_hdl, dev_id, entry)
    return self.recv_match_tbl_deactivate_entry()

  def send_match_tbl_deactivate_entry(self, sess_hdl, dev_id, entry):
    self._oprot.writeMessageBegin('match_tbl_deactivate_entry', TMessageType.CALL, self._seqid)
    args = match_tbl_deactivate_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_deactivate_entry(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_deactivate_entry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_deactivate_entry failed: unknown result");

  def match_tbl_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_match_tbl_set_property(sess_hdl, dev_id, property, value)
    return self.recv_match_tbl_set_property()

  def send_match_tbl_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('match_tbl_set_property', TMessageType.CALL, self._seqid)
    args = match_tbl_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_match_tbl_set_property(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = match_tbl_set_property_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "match_tbl_set_property failed: unknown result");

  def set_learning_timeout(self, sess_hdl, dev_id, usecs):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - usecs
    """
    self.send_set_learning_timeout(sess_hdl, dev_id, usecs)
    return self.recv_set_learning_timeout()

  def send_set_learning_timeout(self, sess_hdl, dev_id, usecs):
    self._oprot.writeMessageBegin('set_learning_timeout', TMessageType.CALL, self._seqid)
    args = set_learning_timeout_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.usecs = usecs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_learning_timeout(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = set_learning_timeout_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_learning_timeout failed: unknown result");

  def tbl_dbg_counter_type_set(self, dev_tgt, tbl_name, type):
    """
    Parameters:
     - dev_tgt
     - tbl_name
     - type
    """
    self.send_tbl_dbg_counter_type_set(dev_tgt, tbl_name, type)
    return self.recv_tbl_dbg_counter_type_set()

  def send_tbl_dbg_counter_type_set(self, dev_tgt, tbl_name, type):
    self._oprot.writeMessageBegin('tbl_dbg_counter_type_set', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_type_set_args()
    args.dev_tgt = dev_tgt
    args.tbl_name = tbl_name
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_type_set(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_type_set_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tbl_dbg_counter_type_set failed: unknown result");

  def tbl_dbg_counter_get(self, dev_tgt, tbl_name):
    """
    Parameters:
     - dev_tgt
     - tbl_name
    """
    self.send_tbl_dbg_counter_get(dev_tgt, tbl_name)
    return self.recv_tbl_dbg_counter_get()

  def send_tbl_dbg_counter_get(self, dev_tgt, tbl_name):
    self._oprot.writeMessageBegin('tbl_dbg_counter_get', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_get_args()
    args.dev_tgt = dev_tgt
    args.tbl_name = tbl_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_get(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tbl_dbg_counter_get failed: unknown result");

  def tbl_dbg_counter_clear(self, dev_tgt, tbl_name):
    """
    Parameters:
     - dev_tgt
     - tbl_name
    """
    self.send_tbl_dbg_counter_clear(dev_tgt, tbl_name)
    return self.recv_tbl_dbg_counter_clear()

  def send_tbl_dbg_counter_clear(self, dev_tgt, tbl_name):
    self._oprot.writeMessageBegin('tbl_dbg_counter_clear', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_clear_args()
    args.dev_tgt = dev_tgt
    args.tbl_name = tbl_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_clear(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_clear_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tbl_dbg_counter_clear failed: unknown result");

  def tbl_dbg_counter_type_stage_set(self, dev_tgt, stage, type):
    """
    Parameters:
     - dev_tgt
     - stage
     - type
    """
    self.send_tbl_dbg_counter_type_stage_set(dev_tgt, stage, type)
    return self.recv_tbl_dbg_counter_type_stage_set()

  def send_tbl_dbg_counter_type_stage_set(self, dev_tgt, stage, type):
    self._oprot.writeMessageBegin('tbl_dbg_counter_type_stage_set', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_type_stage_set_args()
    args.dev_tgt = dev_tgt
    args.stage = stage
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_type_stage_set(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_type_stage_set_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tbl_dbg_counter_type_stage_set failed: unknown result");

  def tbl_dbg_counter_stage_clear(self, dev_tgt, stage):
    """
    Parameters:
     - dev_tgt
     - stage
    """
    self.send_tbl_dbg_counter_stage_clear(dev_tgt, stage)
    return self.recv_tbl_dbg_counter_stage_clear()

  def send_tbl_dbg_counter_stage_clear(self, dev_tgt, stage):
    self._oprot.writeMessageBegin('tbl_dbg_counter_stage_clear', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_stage_clear_args()
    args.dev_tgt = dev_tgt
    args.stage = stage
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_stage_clear(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_stage_clear_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tbl_dbg_counter_stage_clear failed: unknown result");

  def snapshot_create(self, dev_tgt, start_stage, end_stage, direction):
    """
    Parameters:
     - dev_tgt
     - start_stage
     - end_stage
     - direction
    """
    self.send_snapshot_create(dev_tgt, start_stage, end_stage, direction)
    return self.recv_snapshot_create()

  def send_snapshot_create(self, dev_tgt, start_stage, end_stage, direction):
    self._oprot.writeMessageBegin('snapshot_create', TMessageType.CALL, self._seqid)
    args = snapshot_create_args()
    args.dev_tgt = dev_tgt
    args.start_stage = start_stage
    args.end_stage = end_stage
    args.direction = direction
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_create(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snapshot_create_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_create failed: unknown result");

  def snapshot_delete(self, handle):
    """
    Parameters:
     - handle
    """
    self.send_snapshot_delete(handle)
    return self.recv_snapshot_delete()

  def send_snapshot_delete(self, handle):
    self._oprot.writeMessageBegin('snapshot_delete', TMessageType.CALL, self._seqid)
    args = snapshot_delete_args()
    args.handle = handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_delete(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snapshot_delete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_delete failed: unknown result");

  def snapshot_state_set(self, handle, state, usecs):
    """
    Parameters:
     - handle
     - state
     - usecs
    """
    self.send_snapshot_state_set(handle, state, usecs)
    return self.recv_snapshot_state_set()

  def send_snapshot_state_set(self, handle, state, usecs):
    self._oprot.writeMessageBegin('snapshot_state_set', TMessageType.CALL, self._seqid)
    args = snapshot_state_set_args()
    args.handle = handle
    args.state = state
    args.usecs = usecs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_state_set(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snapshot_state_set_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_state_set failed: unknown result");

  def snapshot_state_get(self, handle, pipe):
    """
    Parameters:
     - handle
     - pipe
    """
    self.send_snapshot_state_get(handle, pipe)
    return self.recv_snapshot_state_get()

  def send_snapshot_state_get(self, handle, pipe):
    self._oprot.writeMessageBegin('snapshot_state_get', TMessageType.CALL, self._seqid)
    args = snapshot_state_get_args()
    args.handle = handle
    args.pipe = pipe
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_state_get(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snapshot_state_get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_state_get failed: unknown result");

  def snapshot_timer_enable(self, handle, disable):
    """
    Parameters:
     - handle
     - disable
    """
    self.send_snapshot_timer_enable(handle, disable)
    return self.recv_snapshot_timer_enable()

  def send_snapshot_timer_enable(self, handle, disable):
    self._oprot.writeMessageBegin('snapshot_timer_enable', TMessageType.CALL, self._seqid)
    args = snapshot_timer_enable_args()
    args.handle = handle
    args.disable = disable
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_timer_enable(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snapshot_timer_enable_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_timer_enable failed: unknown result");

  def snapshot_capture_trigger_set(self, handle, trig_spec, trig_spec2):
    """
    Parameters:
     - handle
     - trig_spec
     - trig_spec2
    """
    self.send_snapshot_capture_trigger_set(handle, trig_spec, trig_spec2)
    return self.recv_snapshot_capture_trigger_set()

  def send_snapshot_capture_trigger_set(self, handle, trig_spec, trig_spec2):
    self._oprot.writeMessageBegin('snapshot_capture_trigger_set', TMessageType.CALL, self._seqid)
    args = snapshot_capture_trigger_set_args()
    args.handle = handle
    args.trig_spec = trig_spec
    args.trig_spec2 = trig_spec2
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_capture_trigger_set(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snapshot_capture_trigger_set_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_capture_trigger_set failed: unknown result");

  def snapshot_capture_data_get(self, handle, pipe, stage_id, field_name):
    """
    Parameters:
     - handle
     - pipe
     - stage_id
     - field_name
    """
    self.send_snapshot_capture_data_get(handle, pipe, stage_id, field_name)
    return self.recv_snapshot_capture_data_get()

  def send_snapshot_capture_data_get(self, handle, pipe, stage_id, field_name):
    self._oprot.writeMessageBegin('snapshot_capture_data_get', TMessageType.CALL, self._seqid)
    args = snapshot_capture_data_get_args()
    args.handle = handle
    args.pipe = pipe
    args.stage_id = stage_id
    args.field_name = field_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_capture_data_get(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snapshot_capture_data_get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_capture_data_get failed: unknown result");

  def counter_read_cntr(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    self.send_counter_read_cntr(sess_hdl, dev_tgt, index, flags)
    return self.recv_counter_read_cntr()

  def send_counter_read_cntr(self, sess_hdl, dev_tgt, index, flags):
    self._oprot.writeMessageBegin('counter_read_cntr', TMessageType.CALL, self._seqid)
    args = counter_read_cntr_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.flags = flags
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_counter_read_cntr(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = counter_read_cntr_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "counter_read_cntr failed: unknown result");

  def counter_write_cntr(self, sess_hdl, dev_tgt, index, counter_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - counter_value
    """
    self.send_counter_write_cntr(sess_hdl, dev_tgt, index, counter_value)
    return self.recv_counter_write_cntr()

  def send_counter_write_cntr(self, sess_hdl, dev_tgt, index, counter_value):
    self._oprot.writeMessageBegin('counter_write_cntr', TMessageType.CALL, self._seqid)
    args = counter_write_cntr_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.counter_value = counter_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_counter_write_cntr(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = counter_write_cntr_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "counter_write_cntr failed: unknown result");

  def counter_hw_sync_cntr(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_counter_hw_sync_cntr(sess_hdl, dev_tgt)
    return self.recv_counter_hw_sync_cntr()

  def send_counter_hw_sync_cntr(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('counter_hw_sync_cntr', TMessageType.CALL, self._seqid)
    args = counter_hw_sync_cntr_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_counter_hw_sync_cntr(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = counter_hw_sync_cntr_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "counter_hw_sync_cntr failed: unknown result");

  def meter_set_mtr(self, sess_hdl, dev_tgt, index, meter_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - meter_spec
    """
    self.send_meter_set_mtr(sess_hdl, dev_tgt, index, meter_spec)
    return self.recv_meter_set_mtr()

  def send_meter_set_mtr(self, sess_hdl, dev_tgt, index, meter_spec):
    self._oprot.writeMessageBegin('meter_set_mtr', TMessageType.CALL, self._seqid)
    args = meter_set_mtr_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.meter_spec = meter_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_meter_set_mtr(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = meter_set_mtr_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "meter_set_mtr failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["match_tbl_table_add_with_tcp_sport_modify"] = Processor.process_match_tbl_table_add_with_tcp_sport_modify
    self._processMap["match_tbl_table_add_with_tcp_dport_modify"] = Processor.process_match_tbl_table_add_with_tcp_dport_modify
    self._processMap["match_tbl_table_add_with_ipsa_modify"] = Processor.process_match_tbl_table_add_with_ipsa_modify
    self._processMap["match_tbl_table_add_with_ipda_modify"] = Processor.process_match_tbl_table_add_with_ipda_modify
    self._processMap["match_tbl_table_modify_with_tcp_sport_modify"] = Processor.process_match_tbl_table_modify_with_tcp_sport_modify
    self._processMap["match_tbl_table_modify_with_tcp_dport_modify"] = Processor.process_match_tbl_table_modify_with_tcp_dport_modify
    self._processMap["match_tbl_table_modify_with_ipsa_modify"] = Processor.process_match_tbl_table_modify_with_ipsa_modify
    self._processMap["match_tbl_table_modify_with_ipda_modify"] = Processor.process_match_tbl_table_modify_with_ipda_modify
    self._processMap["match_tbl_table_delete"] = Processor.process_match_tbl_table_delete
    self._processMap["match_tbl_get_first_entry_handle"] = Processor.process_match_tbl_get_first_entry_handle
    self._processMap["match_tbl_get_next_entry_handles"] = Processor.process_match_tbl_get_next_entry_handles
    self._processMap["match_tbl_get_entry"] = Processor.process_match_tbl_get_entry
    self._processMap["match_tbl_set_default_action_tcp_sport_modify"] = Processor.process_match_tbl_set_default_action_tcp_sport_modify
    self._processMap["match_tbl_set_default_action_tcp_dport_modify"] = Processor.process_match_tbl_set_default_action_tcp_dport_modify
    self._processMap["match_tbl_set_default_action_ipsa_modify"] = Processor.process_match_tbl_set_default_action_ipsa_modify
    self._processMap["match_tbl_set_default_action_ipda_modify"] = Processor.process_match_tbl_set_default_action_ipda_modify
    self._processMap["match_tbl_activate_entry"] = Processor.process_match_tbl_activate_entry
    self._processMap["match_tbl_deactivate_entry"] = Processor.process_match_tbl_deactivate_entry
    self._processMap["match_tbl_set_property"] = Processor.process_match_tbl_set_property
    self._processMap["set_learning_timeout"] = Processor.process_set_learning_timeout
    self._processMap["tbl_dbg_counter_type_set"] = Processor.process_tbl_dbg_counter_type_set
    self._processMap["tbl_dbg_counter_get"] = Processor.process_tbl_dbg_counter_get
    self._processMap["tbl_dbg_counter_clear"] = Processor.process_tbl_dbg_counter_clear
    self._processMap["tbl_dbg_counter_type_stage_set"] = Processor.process_tbl_dbg_counter_type_stage_set
    self._processMap["tbl_dbg_counter_stage_clear"] = Processor.process_tbl_dbg_counter_stage_clear
    self._processMap["snapshot_create"] = Processor.process_snapshot_create
    self._processMap["snapshot_delete"] = Processor.process_snapshot_delete
    self._processMap["snapshot_state_set"] = Processor.process_snapshot_state_set
    self._processMap["snapshot_state_get"] = Processor.process_snapshot_state_get
    self._processMap["snapshot_timer_enable"] = Processor.process_snapshot_timer_enable
    self._processMap["snapshot_capture_trigger_set"] = Processor.process_snapshot_capture_trigger_set
    self._processMap["snapshot_capture_data_get"] = Processor.process_snapshot_capture_data_get
    self._processMap["counter_read_cntr"] = Processor.process_counter_read_cntr
    self._processMap["counter_write_cntr"] = Processor.process_counter_write_cntr
    self._processMap["counter_hw_sync_cntr"] = Processor.process_counter_hw_sync_cntr
    self._processMap["meter_set_mtr"] = Processor.process_meter_set_mtr

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_match_tbl_table_add_with_tcp_sport_modify(self, seqid, iprot, oprot):
    args = match_tbl_table_add_with_tcp_sport_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_table_add_with_tcp_sport_modify_result()
    result.success = self._handler.match_tbl_table_add_with_tcp_sport_modify(args.sess_hdl, args.dev_tgt, args.match_spec, args.action_spec)
    oprot.writeMessageBegin("match_tbl_table_add_with_tcp_sport_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_table_add_with_tcp_dport_modify(self, seqid, iprot, oprot):
    args = match_tbl_table_add_with_tcp_dport_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_table_add_with_tcp_dport_modify_result()
    result.success = self._handler.match_tbl_table_add_with_tcp_dport_modify(args.sess_hdl, args.dev_tgt, args.match_spec, args.action_spec)
    oprot.writeMessageBegin("match_tbl_table_add_with_tcp_dport_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_table_add_with_ipsa_modify(self, seqid, iprot, oprot):
    args = match_tbl_table_add_with_ipsa_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_table_add_with_ipsa_modify_result()
    result.success = self._handler.match_tbl_table_add_with_ipsa_modify(args.sess_hdl, args.dev_tgt, args.match_spec, args.action_spec)
    oprot.writeMessageBegin("match_tbl_table_add_with_ipsa_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_table_add_with_ipda_modify(self, seqid, iprot, oprot):
    args = match_tbl_table_add_with_ipda_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_table_add_with_ipda_modify_result()
    result.success = self._handler.match_tbl_table_add_with_ipda_modify(args.sess_hdl, args.dev_tgt, args.match_spec, args.action_spec)
    oprot.writeMessageBegin("match_tbl_table_add_with_ipda_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_table_modify_with_tcp_sport_modify(self, seqid, iprot, oprot):
    args = match_tbl_table_modify_with_tcp_sport_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_table_modify_with_tcp_sport_modify_result()
    result.success = self._handler.match_tbl_table_modify_with_tcp_sport_modify(args.sess_hdl, args.dev_id, args.entry, args.action_spec)
    oprot.writeMessageBegin("match_tbl_table_modify_with_tcp_sport_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_table_modify_with_tcp_dport_modify(self, seqid, iprot, oprot):
    args = match_tbl_table_modify_with_tcp_dport_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_table_modify_with_tcp_dport_modify_result()
    result.success = self._handler.match_tbl_table_modify_with_tcp_dport_modify(args.sess_hdl, args.dev_id, args.entry, args.action_spec)
    oprot.writeMessageBegin("match_tbl_table_modify_with_tcp_dport_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_table_modify_with_ipsa_modify(self, seqid, iprot, oprot):
    args = match_tbl_table_modify_with_ipsa_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_table_modify_with_ipsa_modify_result()
    result.success = self._handler.match_tbl_table_modify_with_ipsa_modify(args.sess_hdl, args.dev_id, args.entry, args.action_spec)
    oprot.writeMessageBegin("match_tbl_table_modify_with_ipsa_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_table_modify_with_ipda_modify(self, seqid, iprot, oprot):
    args = match_tbl_table_modify_with_ipda_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_table_modify_with_ipda_modify_result()
    result.success = self._handler.match_tbl_table_modify_with_ipda_modify(args.sess_hdl, args.dev_id, args.entry, args.action_spec)
    oprot.writeMessageBegin("match_tbl_table_modify_with_ipda_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_table_delete(self, seqid, iprot, oprot):
    args = match_tbl_table_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_table_delete_result()
    result.success = self._handler.match_tbl_table_delete(args.sess_hdl, args.dev_id, args.entry)
    oprot.writeMessageBegin("match_tbl_table_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_get_first_entry_handle(self, seqid, iprot, oprot):
    args = match_tbl_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_get_first_entry_handle_result()
    result.success = self._handler.match_tbl_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    oprot.writeMessageBegin("match_tbl_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_get_next_entry_handles(self, seqid, iprot, oprot):
    args = match_tbl_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_get_next_entry_handles_result()
    result.success = self._handler.match_tbl_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    oprot.writeMessageBegin("match_tbl_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_get_entry(self, seqid, iprot, oprot):
    args = match_tbl_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_get_entry_result()
    result.success = self._handler.match_tbl_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    oprot.writeMessageBegin("match_tbl_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_set_default_action_tcp_sport_modify(self, seqid, iprot, oprot):
    args = match_tbl_set_default_action_tcp_sport_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_set_default_action_tcp_sport_modify_result()
    result.success = self._handler.match_tbl_set_default_action_tcp_sport_modify(args.sess_hdl, args.dev_tgt, args.action_spec)
    oprot.writeMessageBegin("match_tbl_set_default_action_tcp_sport_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_set_default_action_tcp_dport_modify(self, seqid, iprot, oprot):
    args = match_tbl_set_default_action_tcp_dport_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_set_default_action_tcp_dport_modify_result()
    result.success = self._handler.match_tbl_set_default_action_tcp_dport_modify(args.sess_hdl, args.dev_tgt, args.action_spec)
    oprot.writeMessageBegin("match_tbl_set_default_action_tcp_dport_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_set_default_action_ipsa_modify(self, seqid, iprot, oprot):
    args = match_tbl_set_default_action_ipsa_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_set_default_action_ipsa_modify_result()
    result.success = self._handler.match_tbl_set_default_action_ipsa_modify(args.sess_hdl, args.dev_tgt, args.action_spec)
    oprot.writeMessageBegin("match_tbl_set_default_action_ipsa_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_set_default_action_ipda_modify(self, seqid, iprot, oprot):
    args = match_tbl_set_default_action_ipda_modify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_set_default_action_ipda_modify_result()
    result.success = self._handler.match_tbl_set_default_action_ipda_modify(args.sess_hdl, args.dev_tgt, args.action_spec)
    oprot.writeMessageBegin("match_tbl_set_default_action_ipda_modify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_activate_entry(self, seqid, iprot, oprot):
    args = match_tbl_activate_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_activate_entry_result()
    result.success = self._handler.match_tbl_activate_entry(args.sess_hdl, args.dev_id, args.entry)
    oprot.writeMessageBegin("match_tbl_activate_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_deactivate_entry(self, seqid, iprot, oprot):
    args = match_tbl_deactivate_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_deactivate_entry_result()
    result.success = self._handler.match_tbl_deactivate_entry(args.sess_hdl, args.dev_id, args.entry)
    oprot.writeMessageBegin("match_tbl_deactivate_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_match_tbl_set_property(self, seqid, iprot, oprot):
    args = match_tbl_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = match_tbl_set_property_result()
    result.success = self._handler.match_tbl_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    oprot.writeMessageBegin("match_tbl_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_learning_timeout(self, seqid, iprot, oprot):
    args = set_learning_timeout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_learning_timeout_result()
    result.success = self._handler.set_learning_timeout(args.sess_hdl, args.dev_id, args.usecs)
    oprot.writeMessageBegin("set_learning_timeout", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_type_set(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_type_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_type_set_result()
    result.success = self._handler.tbl_dbg_counter_type_set(args.dev_tgt, args.tbl_name, args.type)
    oprot.writeMessageBegin("tbl_dbg_counter_type_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_get(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_get_result()
    result.success = self._handler.tbl_dbg_counter_get(args.dev_tgt, args.tbl_name)
    oprot.writeMessageBegin("tbl_dbg_counter_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_clear(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_clear_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_clear_result()
    result.success = self._handler.tbl_dbg_counter_clear(args.dev_tgt, args.tbl_name)
    oprot.writeMessageBegin("tbl_dbg_counter_clear", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_type_stage_set(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_type_stage_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_type_stage_set_result()
    result.success = self._handler.tbl_dbg_counter_type_stage_set(args.dev_tgt, args.stage, args.type)
    oprot.writeMessageBegin("tbl_dbg_counter_type_stage_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_stage_clear(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_stage_clear_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_stage_clear_result()
    result.success = self._handler.tbl_dbg_counter_stage_clear(args.dev_tgt, args.stage)
    oprot.writeMessageBegin("tbl_dbg_counter_stage_clear", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_create(self, seqid, iprot, oprot):
    args = snapshot_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_create_result()
    result.success = self._handler.snapshot_create(args.dev_tgt, args.start_stage, args.end_stage, args.direction)
    oprot.writeMessageBegin("snapshot_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_delete(self, seqid, iprot, oprot):
    args = snapshot_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_delete_result()
    result.success = self._handler.snapshot_delete(args.handle)
    oprot.writeMessageBegin("snapshot_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_state_set(self, seqid, iprot, oprot):
    args = snapshot_state_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_state_set_result()
    result.success = self._handler.snapshot_state_set(args.handle, args.state, args.usecs)
    oprot.writeMessageBegin("snapshot_state_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_state_get(self, seqid, iprot, oprot):
    args = snapshot_state_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_state_get_result()
    result.success = self._handler.snapshot_state_get(args.handle, args.pipe)
    oprot.writeMessageBegin("snapshot_state_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_timer_enable(self, seqid, iprot, oprot):
    args = snapshot_timer_enable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_timer_enable_result()
    result.success = self._handler.snapshot_timer_enable(args.handle, args.disable)
    oprot.writeMessageBegin("snapshot_timer_enable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_capture_trigger_set(self, seqid, iprot, oprot):
    args = snapshot_capture_trigger_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_capture_trigger_set_result()
    result.success = self._handler.snapshot_capture_trigger_set(args.handle, args.trig_spec, args.trig_spec2)
    oprot.writeMessageBegin("snapshot_capture_trigger_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_capture_data_get(self, seqid, iprot, oprot):
    args = snapshot_capture_data_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_capture_data_get_result()
    result.success = self._handler.snapshot_capture_data_get(args.handle, args.pipe, args.stage_id, args.field_name)
    oprot.writeMessageBegin("snapshot_capture_data_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_counter_read_cntr(self, seqid, iprot, oprot):
    args = counter_read_cntr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = counter_read_cntr_result()
    result.success = self._handler.counter_read_cntr(args.sess_hdl, args.dev_tgt, args.index, args.flags)
    oprot.writeMessageBegin("counter_read_cntr", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_counter_write_cntr(self, seqid, iprot, oprot):
    args = counter_write_cntr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = counter_write_cntr_result()
    result.success = self._handler.counter_write_cntr(args.sess_hdl, args.dev_tgt, args.index, args.counter_value)
    oprot.writeMessageBegin("counter_write_cntr", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_counter_hw_sync_cntr(self, seqid, iprot, oprot):
    args = counter_hw_sync_cntr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = counter_hw_sync_cntr_result()
    result.success = self._handler.counter_hw_sync_cntr(args.sess_hdl, args.dev_tgt)
    oprot.writeMessageBegin("counter_hw_sync_cntr", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_meter_set_mtr(self, seqid, iprot, oprot):
    args = meter_set_mtr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = meter_set_mtr_result()
    result.success = self._handler.meter_set_mtr(args.sess_hdl, args.dev_tgt, args.index, args.meter_spec)
    oprot.writeMessageBegin("meter_set_mtr", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class match_tbl_table_add_with_tcp_sport_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (bfd_test_match_tbl_match_spec_t, bfd_test_match_tbl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'action_spec', (bfd_test_tcp_sport_modify_action_spec_t, bfd_test_tcp_sport_modify_action_spec_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = bfd_test_match_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_tcp_sport_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_add_with_tcp_sport_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_add_with_tcp_sport_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_add_with_tcp_sport_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_add_with_tcp_dport_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (bfd_test_match_tbl_match_spec_t, bfd_test_match_tbl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'action_spec', (bfd_test_tcp_dport_modify_action_spec_t, bfd_test_tcp_dport_modify_action_spec_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = bfd_test_match_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_tcp_dport_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_add_with_tcp_dport_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_add_with_tcp_dport_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_add_with_tcp_dport_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_add_with_ipsa_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (bfd_test_match_tbl_match_spec_t, bfd_test_match_tbl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'action_spec', (bfd_test_ipsa_modify_action_spec_t, bfd_test_ipsa_modify_action_spec_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = bfd_test_match_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_ipsa_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_add_with_ipsa_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_add_with_ipsa_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_add_with_ipsa_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_add_with_ipda_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (bfd_test_match_tbl_match_spec_t, bfd_test_match_tbl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'action_spec', (bfd_test_ipda_modify_action_spec_t, bfd_test_ipda_modify_action_spec_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = bfd_test_match_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_ipda_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_add_with_ipda_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_add_with_ipda_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_add_with_ipda_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_modify_with_tcp_sport_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
    (4, TType.STRUCT, 'action_spec', (bfd_test_tcp_sport_modify_action_spec_t, bfd_test_tcp_sport_modify_action_spec_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_tcp_sport_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_modify_with_tcp_sport_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_modify_with_tcp_sport_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_modify_with_tcp_sport_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_modify_with_tcp_dport_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
    (4, TType.STRUCT, 'action_spec', (bfd_test_tcp_dport_modify_action_spec_t, bfd_test_tcp_dport_modify_action_spec_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_tcp_dport_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_modify_with_tcp_dport_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_modify_with_tcp_dport_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_modify_with_tcp_dport_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_modify_with_ipsa_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
    (4, TType.STRUCT, 'action_spec', (bfd_test_ipsa_modify_action_spec_t, bfd_test_ipsa_modify_action_spec_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_ipsa_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_modify_with_ipsa_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_modify_with_ipsa_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_modify_with_ipsa_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_modify_with_ipda_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
    (4, TType.STRUCT, 'action_spec', (bfd_test_ipda_modify_action_spec_t, bfd_test_ipda_modify_action_spec_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_ipda_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_modify_with_ipda_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_modify_with_ipda_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_modify_with_ipda_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_delete_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_delete_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_table_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_table_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_get_first_entry_handle_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_get_next_entry_handles_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readI32();
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter13 in self.success:
        oprot.writeI32(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_get_entry_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (bfd_test_match_tbl_entry_desc_t, bfd_test_match_tbl_entry_desc_t.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = bfd_test_match_tbl_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_default_action_tcp_sport_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'action_spec', (bfd_test_tcp_sport_modify_action_spec_t, bfd_test_tcp_sport_modify_action_spec_t.thrift_spec), None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_tcp_sport_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_default_action_tcp_sport_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 3)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_default_action_tcp_sport_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_default_action_tcp_sport_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_default_action_tcp_dport_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'action_spec', (bfd_test_tcp_dport_modify_action_spec_t, bfd_test_tcp_dport_modify_action_spec_t.thrift_spec), None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_tcp_dport_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_default_action_tcp_dport_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 3)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_default_action_tcp_dport_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_default_action_tcp_dport_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_default_action_ipsa_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'action_spec', (bfd_test_ipsa_modify_action_spec_t, bfd_test_ipsa_modify_action_spec_t.thrift_spec), None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_ipsa_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_default_action_ipsa_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 3)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_default_action_ipsa_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_default_action_ipsa_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_default_action_ipda_modify_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'action_spec', (bfd_test_ipda_modify_action_spec_t, bfd_test_ipda_modify_action_spec_t.thrift_spec), None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.action_spec = bfd_test_ipda_modify_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_default_action_ipda_modify_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 3)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_default_action_ipda_modify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_default_action_ipda_modify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_activate_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_activate_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_activate_entry_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_activate_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_deactivate_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_deactivate_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_deactivate_entry_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_deactivate_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_tbl_set_property_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_tbl_set_property_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_learning_timeout_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - usecs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'usecs', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_id=None, usecs=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.usecs = usecs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.usecs = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_learning_timeout_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.usecs is not None:
      oprot.writeFieldBegin('usecs', TType.I32, 3)
      oprot.writeI32(self.usecs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_learning_timeout_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_learning_timeout_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_type_set_args:
  """
  Attributes:
   - dev_tgt
   - tbl_name
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, dev_tgt=None, tbl_name=None, type=None,):
    self.dev_tgt = dev_tgt
    self.tbl_name = tbl_name
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_type_set_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_type_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_type_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_get_args:
  """
  Attributes:
   - dev_tgt
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, dev_tgt=None, tbl_name=None,):
    self.dev_tgt = dev_tgt
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_get_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_get_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_clear_args:
  """
  Attributes:
   - dev_tgt
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, dev_tgt=None, tbl_name=None,):
    self.dev_tgt = dev_tgt
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_clear_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_clear_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_clear_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_type_stage_set_args:
  """
  Attributes:
   - dev_tgt
   - stage
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.BYTE, 'stage', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, dev_tgt=None, stage=None, type=None,):
    self.dev_tgt = dev_tgt
    self.stage = stage
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.stage = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_type_stage_set_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.stage is not None:
      oprot.writeFieldBegin('stage', TType.BYTE, 2)
      oprot.writeByte(self.stage)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_type_stage_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_type_stage_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_stage_clear_args:
  """
  Attributes:
   - dev_tgt
   - stage
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.BYTE, 'stage', None, None, ), # 2
  )

  def __init__(self, dev_tgt=None, stage=None,):
    self.dev_tgt = dev_tgt
    self.stage = stage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.stage = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_stage_clear_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.stage is not None:
      oprot.writeFieldBegin('stage', TType.BYTE, 2)
      oprot.writeByte(self.stage)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_stage_clear_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_stage_clear_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_create_args:
  """
  Attributes:
   - dev_tgt
   - start_stage
   - end_stage
   - direction
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.BYTE, 'start_stage', None, None, ), # 2
    (3, TType.BYTE, 'end_stage', None, None, ), # 3
    (4, TType.BYTE, 'direction', None, None, ), # 4
  )

  def __init__(self, dev_tgt=None, start_stage=None, end_stage=None, direction=None,):
    self.dev_tgt = dev_tgt
    self.start_stage = start_stage
    self.end_stage = end_stage
    self.direction = direction

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.start_stage = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.end_stage = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.direction = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_create_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.start_stage is not None:
      oprot.writeFieldBegin('start_stage', TType.BYTE, 2)
      oprot.writeByte(self.start_stage)
      oprot.writeFieldEnd()
    if self.end_stage is not None:
      oprot.writeFieldBegin('end_stage', TType.BYTE, 3)
      oprot.writeByte(self.end_stage)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.BYTE, 4)
      oprot.writeByte(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_delete_args:
  """
  Attributes:
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
  )

  def __init__(self, handle=None,):
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_delete_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_state_set_args:
  """
  Attributes:
   - handle
   - state
   - usecs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.I32, 'state', None, None, ), # 2
    (3, TType.I32, 'usecs', None, None, ), # 3
  )

  def __init__(self, handle=None, state=None, usecs=None,):
    self.handle = handle
    self.state = state
    self.usecs = usecs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.usecs = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_state_set_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 2)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.usecs is not None:
      oprot.writeFieldBegin('usecs', TType.I32, 3)
      oprot.writeI32(self.usecs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_state_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_state_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_state_get_args:
  """
  Attributes:
   - handle
   - pipe
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.I16, 'pipe', None, None, ), # 2
  )

  def __init__(self, handle=None, pipe=None,):
    self.handle = handle
    self.pipe = pipe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.pipe = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_state_get_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I16, 2)
      oprot.writeI16(self.pipe)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_state_get_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_state_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_timer_enable_args:
  """
  Attributes:
   - handle
   - disable
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.BYTE, 'disable', None, None, ), # 2
  )

  def __init__(self, handle=None, disable=None,):
    self.handle = handle
    self.disable = disable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.disable = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_timer_enable_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.disable is not None:
      oprot.writeFieldBegin('disable', TType.BYTE, 2)
      oprot.writeByte(self.disable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_timer_enable_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_timer_enable_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_capture_trigger_set_args:
  """
  Attributes:
   - handle
   - trig_spec
   - trig_spec2
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.STRUCT, 'trig_spec', (bfd_test_snapshot_trig_spec_t, bfd_test_snapshot_trig_spec_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'trig_spec2', (bfd_test_snapshot_trig_spec_t, bfd_test_snapshot_trig_spec_t.thrift_spec), None, ), # 3
  )

  def __init__(self, handle=None, trig_spec=None, trig_spec2=None,):
    self.handle = handle
    self.trig_spec = trig_spec
    self.trig_spec2 = trig_spec2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.trig_spec = bfd_test_snapshot_trig_spec_t()
          self.trig_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.trig_spec2 = bfd_test_snapshot_trig_spec_t()
          self.trig_spec2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_capture_trigger_set_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.trig_spec is not None:
      oprot.writeFieldBegin('trig_spec', TType.STRUCT, 2)
      self.trig_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.trig_spec2 is not None:
      oprot.writeFieldBegin('trig_spec2', TType.STRUCT, 3)
      self.trig_spec2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_capture_trigger_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_capture_trigger_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_capture_data_get_args:
  """
  Attributes:
   - handle
   - pipe
   - stage_id
   - field_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.I16, 'pipe', None, None, ), # 2
    (3, TType.I16, 'stage_id', None, None, ), # 3
    (4, TType.STRING, 'field_name', None, None, ), # 4
  )

  def __init__(self, handle=None, pipe=None, stage_id=None, field_name=None,):
    self.handle = handle
    self.pipe = pipe
    self.stage_id = stage_id
    self.field_name = field_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.pipe = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.stage_id = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.field_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_capture_data_get_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I16, 2)
      oprot.writeI16(self.pipe)
      oprot.writeFieldEnd()
    if self.stage_id is not None:
      oprot.writeFieldBegin('stage_id', TType.I16, 3)
      oprot.writeI16(self.stage_id)
      oprot.writeFieldEnd()
    if self.field_name is not None:
      oprot.writeFieldBegin('field_name', TType.STRING, 4)
      oprot.writeString(self.field_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_capture_data_get_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_capture_data_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class counter_read_cntr_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - flags
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'flags', (bfd_test_counter_flags_t, bfd_test_counter_flags_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, flags=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.flags = flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.flags = bfd_test_counter_flags_t()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('counter_read_cntr_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 4)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class counter_read_cntr_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (bfd_test_counter_value_t, bfd_test_counter_value_t.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = bfd_test_counter_value_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('counter_read_cntr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class counter_write_cntr_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - counter_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'counter_value', (bfd_test_counter_value_t, bfd_test_counter_value_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, counter_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.counter_value = counter_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.counter_value = bfd_test_counter_value_t()
          self.counter_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('counter_write_cntr_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.counter_value is not None:
      oprot.writeFieldBegin('counter_value', TType.STRUCT, 4)
      self.counter_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class counter_write_cntr_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('counter_write_cntr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class counter_hw_sync_cntr_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('counter_hw_sync_cntr_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class counter_hw_sync_cntr_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('counter_hw_sync_cntr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class meter_set_mtr_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - meter_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'meter_spec', (bfd_test_bytes_meter_spec_t, bfd_test_bytes_meter_spec_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, meter_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.meter_spec = meter_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.meter_spec = bfd_test_bytes_meter_spec_t()
          self.meter_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('meter_set_mtr_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.meter_spec is not None:
      oprot.writeFieldBegin('meter_spec', TType.STRUCT, 4)
      self.meter_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class meter_set_mtr_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('meter_set_mtr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
