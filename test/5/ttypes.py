#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import res_pd_rpc.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class bfd_test_idle_time_mode:
  POLL_MODE = 0
  NOTIFY_MODE = 1

  _VALUES_TO_NAMES = {
    0: "POLL_MODE",
    1: "NOTIFY_MODE",
  }

  _NAMES_TO_VALUES = {
    "POLL_MODE": 0,
    "NOTIFY_MODE": 1,
  }

class bfd_test_idle_time_hit_state:
  ENTRY_IDLE = 0
  ENTRY_ACTIVE = 1

  _VALUES_TO_NAMES = {
    0: "ENTRY_IDLE",
    1: "ENTRY_ACTIVE",
  }

  _NAMES_TO_VALUES = {
    "ENTRY_IDLE": 0,
    "ENTRY_ACTIVE": 1,
  }

class tbl_property_t:
  TBL_PROP_TBL_ENTRY_SCOPE_ALL_PIPES = 1
  TBL_PROP_APP_MANAGED_TERN_ENTRY_PLACEMENT = 2

  _VALUES_TO_NAMES = {
    1: "TBL_PROP_TBL_ENTRY_SCOPE_ALL_PIPES",
    2: "TBL_PROP_APP_MANAGED_TERN_ENTRY_PLACEMENT",
  }

  _NAMES_TO_VALUES = {
    "TBL_PROP_TBL_ENTRY_SCOPE_ALL_PIPES": 1,
    "TBL_PROP_APP_MANAGED_TERN_ENTRY_PLACEMENT": 2,
  }


class bfd_test_counter_value_t:
  """
  Attributes:
   - packets
   - bytes
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'packets', None, None, ), # 1
    (2, TType.I64, 'bytes', None, None, ), # 2
  )

  def __init__(self, packets=None, bytes=None,):
    self.packets = packets
    self.bytes = bytes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.packets = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.bytes = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_counter_value_t')
    if self.packets is not None:
      oprot.writeFieldBegin('packets', TType.I64, 1)
      oprot.writeI64(self.packets)
      oprot.writeFieldEnd()
    if self.bytes is not None:
      oprot.writeFieldBegin('bytes', TType.I64, 2)
      oprot.writeI64(self.bytes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.packets is None:
      raise TProtocol.TProtocolException(message='Required field packets is unset!')
    if self.bytes is None:
      raise TProtocol.TProtocolException(message='Required field bytes is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_packets_meter_spec_t:
  """
  Attributes:
   - cir_pps
   - cburst_pkts
   - pir_pps
   - pburst_pkts
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cir_pps', None, None, ), # 1
    (2, TType.I32, 'cburst_pkts', None, None, ), # 2
    (3, TType.I32, 'pir_pps', None, None, ), # 3
    (4, TType.I32, 'pburst_pkts', None, None, ), # 4
  )

  def __init__(self, cir_pps=None, cburst_pkts=None, pir_pps=None, pburst_pkts=None,):
    self.cir_pps = cir_pps
    self.cburst_pkts = cburst_pkts
    self.pir_pps = pir_pps
    self.pburst_pkts = pburst_pkts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cir_pps = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cburst_pkts = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.pir_pps = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.pburst_pkts = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_packets_meter_spec_t')
    if self.cir_pps is not None:
      oprot.writeFieldBegin('cir_pps', TType.I32, 1)
      oprot.writeI32(self.cir_pps)
      oprot.writeFieldEnd()
    if self.cburst_pkts is not None:
      oprot.writeFieldBegin('cburst_pkts', TType.I32, 2)
      oprot.writeI32(self.cburst_pkts)
      oprot.writeFieldEnd()
    if self.pir_pps is not None:
      oprot.writeFieldBegin('pir_pps', TType.I32, 3)
      oprot.writeI32(self.pir_pps)
      oprot.writeFieldEnd()
    if self.pburst_pkts is not None:
      oprot.writeFieldBegin('pburst_pkts', TType.I32, 4)
      oprot.writeI32(self.pburst_pkts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.cir_pps is None:
      raise TProtocol.TProtocolException(message='Required field cir_pps is unset!')
    if self.cburst_pkts is None:
      raise TProtocol.TProtocolException(message='Required field cburst_pkts is unset!')
    if self.pir_pps is None:
      raise TProtocol.TProtocolException(message='Required field pir_pps is unset!')
    if self.pburst_pkts is None:
      raise TProtocol.TProtocolException(message='Required field pburst_pkts is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_bytes_meter_spec_t:
  """
  Attributes:
   - cir_kbps
   - cburst_kbits
   - pir_kbps
   - pburst_kbits
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cir_kbps', None, None, ), # 1
    (2, TType.I32, 'cburst_kbits', None, None, ), # 2
    (3, TType.I32, 'pir_kbps', None, None, ), # 3
    (4, TType.I32, 'pburst_kbits', None, None, ), # 4
  )

  def __init__(self, cir_kbps=None, cburst_kbits=None, pir_kbps=None, pburst_kbits=None,):
    self.cir_kbps = cir_kbps
    self.cburst_kbits = cburst_kbits
    self.pir_kbps = pir_kbps
    self.pburst_kbits = pburst_kbits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cir_kbps = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cburst_kbits = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.pir_kbps = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.pburst_kbits = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_bytes_meter_spec_t')
    if self.cir_kbps is not None:
      oprot.writeFieldBegin('cir_kbps', TType.I32, 1)
      oprot.writeI32(self.cir_kbps)
      oprot.writeFieldEnd()
    if self.cburst_kbits is not None:
      oprot.writeFieldBegin('cburst_kbits', TType.I32, 2)
      oprot.writeI32(self.cburst_kbits)
      oprot.writeFieldEnd()
    if self.pir_kbps is not None:
      oprot.writeFieldBegin('pir_kbps', TType.I32, 3)
      oprot.writeI32(self.pir_kbps)
      oprot.writeFieldEnd()
    if self.pburst_kbits is not None:
      oprot.writeFieldBegin('pburst_kbits', TType.I32, 4)
      oprot.writeI32(self.pburst_kbits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.cir_kbps is None:
      raise TProtocol.TProtocolException(message='Required field cir_kbps is unset!')
    if self.cburst_kbits is None:
      raise TProtocol.TProtocolException(message='Required field cburst_kbits is unset!')
    if self.pir_kbps is None:
      raise TProtocol.TProtocolException(message='Required field pir_kbps is unset!')
    if self.pburst_kbits is None:
      raise TProtocol.TProtocolException(message='Required field pburst_kbits is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_idle_time_params_t:
  """
  Attributes:
   - mode
   - ttl_query_interval
   - max_ttl
   - min_ttl
   - cookie
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'mode', None, None, ), # 1
    (2, TType.I32, 'ttl_query_interval', None, None, ), # 2
    (3, TType.I32, 'max_ttl', None, None, ), # 3
    (4, TType.I32, 'min_ttl', None, None, ), # 4
    (5, TType.I32, 'cookie', None, None, ), # 5
  )

  def __init__(self, mode=None, ttl_query_interval=None, max_ttl=None, min_ttl=None, cookie=None,):
    self.mode = mode
    self.ttl_query_interval = ttl_query_interval
    self.max_ttl = max_ttl
    self.min_ttl = min_ttl
    self.cookie = cookie

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ttl_query_interval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.max_ttl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.min_ttl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cookie = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_idle_time_params_t')
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 1)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    if self.ttl_query_interval is not None:
      oprot.writeFieldBegin('ttl_query_interval', TType.I32, 2)
      oprot.writeI32(self.ttl_query_interval)
      oprot.writeFieldEnd()
    if self.max_ttl is not None:
      oprot.writeFieldBegin('max_ttl', TType.I32, 3)
      oprot.writeI32(self.max_ttl)
      oprot.writeFieldEnd()
    if self.min_ttl is not None:
      oprot.writeFieldBegin('min_ttl', TType.I32, 4)
      oprot.writeI32(self.min_ttl)
      oprot.writeFieldEnd()
    if self.cookie is not None:
      oprot.writeFieldBegin('cookie', TType.I32, 5)
      oprot.writeI32(self.cookie)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.mode is None:
      raise TProtocol.TProtocolException(message='Required field mode is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_idle_tmo_expired_t:
  """
  Attributes:
   - dev_id
   - entry
   - cookie
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev_id', None, None, ), # 1
    (2, TType.I32, 'entry', None, None, ), # 2
    (3, TType.I32, 'cookie', None, None, ), # 3
  )

  def __init__(self, dev_id=None, entry=None, cookie=None,):
    self.dev_id = dev_id
    self.entry = entry
    self.cookie = cookie

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cookie = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_idle_tmo_expired_t')
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.I32, 1)
      oprot.writeI32(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 2)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    if self.cookie is not None:
      oprot.writeFieldBegin('cookie', TType.I32, 3)
      oprot.writeI32(self.cookie)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dev_id is None:
      raise TProtocol.TProtocolException(message='Required field dev_id is unset!')
    if self.entry is None:
      raise TProtocol.TProtocolException(message='Required field entry is unset!')
    if self.cookie is None:
      raise TProtocol.TProtocolException(message='Required field cookie is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_counter_flags_t:
  """
  Attributes:
   - read_hw_sync
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'read_hw_sync', None, None, ), # 1
  )

  def __init__(self, read_hw_sync=None,):
    self.read_hw_sync = read_hw_sync

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.read_hw_sync = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_counter_flags_t')
    if self.read_hw_sync is not None:
      oprot.writeFieldBegin('read_hw_sync', TType.BOOL, 1)
      oprot.writeBool(self.read_hw_sync)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.read_hw_sync is None:
      raise TProtocol.TProtocolException(message='Required field read_hw_sync is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_snapshot_trig_spec_t:
  """
  Attributes:
   - field_name
   - field_value
   - field_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'field_name', None, None, ), # 1
    (2, TType.I64, 'field_value', None, None, ), # 2
    (3, TType.I64, 'field_mask', None, None, ), # 3
  )

  def __init__(self, field_name=None, field_value=None, field_mask=None,):
    self.field_name = field_name
    self.field_value = field_value
    self.field_mask = field_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.field_value = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.field_mask = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_snapshot_trig_spec_t')
    if self.field_name is not None:
      oprot.writeFieldBegin('field_name', TType.STRING, 1)
      oprot.writeString(self.field_name)
      oprot.writeFieldEnd()
    if self.field_value is not None:
      oprot.writeFieldBegin('field_value', TType.I64, 2)
      oprot.writeI64(self.field_value)
      oprot.writeFieldEnd()
    if self.field_mask is not None:
      oprot.writeFieldBegin('field_mask', TType.I64, 3)
      oprot.writeI64(self.field_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.field_name is None:
      raise TProtocol.TProtocolException(message='Required field field_name is unset!')
    if self.field_value is None:
      raise TProtocol.TProtocolException(message='Required field field_value is unset!')
    if self.field_mask is None:
      raise TProtocol.TProtocolException(message='Required field field_mask is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_match_tbl_match_spec_t:
  """
  Attributes:
   - ipv4_dstAddr
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ipv4_dstAddr', None, None, ), # 1
  )

  def __init__(self, ipv4_dstAddr=None,):
    self.ipv4_dstAddr = ipv4_dstAddr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ipv4_dstAddr = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_match_tbl_match_spec_t')
    if self.ipv4_dstAddr is not None:
      oprot.writeFieldBegin('ipv4_dstAddr', TType.I32, 1)
      oprot.writeI32(self.ipv4_dstAddr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ipv4_dstAddr is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_dstAddr is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_tcp_sport_modify_action_spec_t:
  """
  Attributes:
   - action_sPort
   - action_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_sPort', None, None, ), # 1
    (2, TType.I32, 'action_port', None, None, ), # 2
  )

  def __init__(self, action_sPort=None, action_port=None,):
    self.action_sPort = action_sPort
    self.action_port = action_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_sPort = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_tcp_sport_modify_action_spec_t')
    if self.action_sPort is not None:
      oprot.writeFieldBegin('action_sPort', TType.I32, 1)
      oprot.writeI32(self.action_sPort)
      oprot.writeFieldEnd()
    if self.action_port is not None:
      oprot.writeFieldBegin('action_port', TType.I32, 2)
      oprot.writeI32(self.action_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_sPort is None:
      raise TProtocol.TProtocolException(message='Required field action_sPort is unset!')
    if self.action_port is None:
      raise TProtocol.TProtocolException(message='Required field action_port is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_tcp_dport_modify_action_spec_t:
  """
  Attributes:
   - action_dPort
   - action_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_dPort', None, None, ), # 1
    (2, TType.I32, 'action_port', None, None, ), # 2
  )

  def __init__(self, action_dPort=None, action_port=None,):
    self.action_dPort = action_dPort
    self.action_port = action_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_dPort = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_tcp_dport_modify_action_spec_t')
    if self.action_dPort is not None:
      oprot.writeFieldBegin('action_dPort', TType.I32, 1)
      oprot.writeI32(self.action_dPort)
      oprot.writeFieldEnd()
    if self.action_port is not None:
      oprot.writeFieldBegin('action_port', TType.I32, 2)
      oprot.writeI32(self.action_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_dPort is None:
      raise TProtocol.TProtocolException(message='Required field action_dPort is unset!')
    if self.action_port is None:
      raise TProtocol.TProtocolException(message='Required field action_port is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_ipsa_modify_action_spec_t:
  """
  Attributes:
   - action_ipsa
   - action_port
   - action_stat_idx
   - action_meter_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_ipsa', None, None, ), # 1
    (2, TType.I32, 'action_port', None, None, ), # 2
    (3, TType.I32, 'action_stat_idx', None, None, ), # 3
    (4, TType.I32, 'action_meter_idx', None, None, ), # 4
  )

  def __init__(self, action_ipsa=None, action_port=None, action_stat_idx=None, action_meter_idx=None,):
    self.action_ipsa = action_ipsa
    self.action_port = action_port
    self.action_stat_idx = action_stat_idx
    self.action_meter_idx = action_meter_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_ipsa = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.action_stat_idx = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.action_meter_idx = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_ipsa_modify_action_spec_t')
    if self.action_ipsa is not None:
      oprot.writeFieldBegin('action_ipsa', TType.I32, 1)
      oprot.writeI32(self.action_ipsa)
      oprot.writeFieldEnd()
    if self.action_port is not None:
      oprot.writeFieldBegin('action_port', TType.I32, 2)
      oprot.writeI32(self.action_port)
      oprot.writeFieldEnd()
    if self.action_stat_idx is not None:
      oprot.writeFieldBegin('action_stat_idx', TType.I32, 3)
      oprot.writeI32(self.action_stat_idx)
      oprot.writeFieldEnd()
    if self.action_meter_idx is not None:
      oprot.writeFieldBegin('action_meter_idx', TType.I32, 4)
      oprot.writeI32(self.action_meter_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ipsa is None:
      raise TProtocol.TProtocolException(message='Required field action_ipsa is unset!')
    if self.action_port is None:
      raise TProtocol.TProtocolException(message='Required field action_port is unset!')
    if self.action_stat_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_stat_idx is unset!')
    if self.action_meter_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_meter_idx is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_ipda_modify_action_spec_t:
  """
  Attributes:
   - action_ipda
   - action_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_ipda', None, None, ), # 1
    (2, TType.I32, 'action_port', None, None, ), # 2
  )

  def __init__(self, action_ipda=None, action_port=None,):
    self.action_ipda = action_ipda
    self.action_port = action_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_ipda = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_ipda_modify_action_spec_t')
    if self.action_ipda is not None:
      oprot.writeFieldBegin('action_ipda', TType.I32, 1)
      oprot.writeI32(self.action_ipda)
      oprot.writeFieldEnd()
    if self.action_port is not None:
      oprot.writeFieldBegin('action_port', TType.I32, 2)
      oprot.writeI32(self.action_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ipda is None:
      raise TProtocol.TProtocolException(message='Required field action_ipda is unset!')
    if self.action_port is None:
      raise TProtocol.TProtocolException(message='Required field action_port is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_action_desc_t:
  """
  Attributes:
   - name
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.LIST, 'data', (TType.BYTE,None), None, ), # 2
  )

  def __init__(self, name=None, data=None,):
    self.name = name
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.data = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readByte();
            self.data.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_action_desc_t')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.LIST, 2)
      oprot.writeListBegin(TType.BYTE, len(self.data))
      for iter6 in self.data:
        oprot.writeByte(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.data is None:
      raise TProtocol.TProtocolException(message='Required field data is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bfd_test_match_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (bfd_test_match_tbl_match_spec_t, bfd_test_match_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'action_desc', (bfd_test_action_desc_t, bfd_test_action_desc_t.thrift_spec), None, ), # 2
  )

  def __init__(self, match_spec=None, action_desc=None,):
    self.match_spec = match_spec
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = bfd_test_match_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.action_desc = bfd_test_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bfd_test_match_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 2)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
